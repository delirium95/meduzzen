from sqlalchemy.orm import Session
from fastapi import HTTPException, status, UploadFile
from models import Chat, Message, ChatMember, FileAttachment, User, ChatType, MemberRole, MemberStatus
from typing import List, Optional
import os
import shutil
from datetime import datetime
import logging

# –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ –ª–æ–≥—É–≤–∞–Ω–Ω—è
logger = logging.getLogger(__name__)

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è —Ñ–∞–π–ª—ñ–≤
UPLOAD_DIR = "uploads"
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
ALLOWED_EXTENSIONS = {".txt", ".pdf", ".doc", ".docx", ".jpg", ".jpeg", ".png", ".gif"}

# –°—Ç–≤–æ—Ä—é—î–º–æ –ø–∞–ø–∫—É –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω—å
os.makedirs(UPLOAD_DIR, exist_ok=True)

def create_private_chat(db: Session, creator_id: int, recipient_id: int) -> Chat:
    """–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ —á–∞—Ç—É –º—ñ–∂ –¥–≤–æ–º–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞–º–∏"""
    logger.info(f"üîç Creating private chat: creator_id={creator_id}, recipient_id={recipient_id}")
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —ñ—Å–Ω—É—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á
    recipient = db.query(User).filter(User.id == recipient_id).first()
    if not recipient:
        logger.error(f"‚ùå Recipient user {recipient_id} not found")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Recipient user not found"
        )
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –Ω–µ —Å—Ç–≤–æ—Ä—é—î–º–æ —á–∞—Ç –∑ —Å–∞–º–∏–º —Å–æ–±–æ—é
    if creator_id == recipient_id:
        logger.error(f"‚ùå Cannot create chat with yourself")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot create chat with yourself"
        )
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ —ñ—Å–Ω—É—î —á–∞—Ç –º—ñ–∂ —Ü–∏–º–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞–º–∏
    existing_chat = db.query(Chat).filter(
        ((Chat.creator_id == creator_id) & (Chat.recipient_id == recipient_id)) |
        ((Chat.creator_id == recipient_id) & (Chat.recipient_id == creator_id)),
        Chat.chat_type == ChatType.PRIVATE
    ).first()
    
    if existing_chat:
        logger.info(f"‚úÖ Found existing chat: {existing_chat.id}")
        # Ensure both users are members (idempotent fix for previously missing members)
        _ensure_user_membership(db, existing_chat.id, creator_id)
        _ensure_user_membership(db, existing_chat.id, recipient_id)
        return existing_chat
    
    # –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π –ø—Ä–∏–≤–∞—Ç–Ω–∏–π —á–∞—Ç
    chat = Chat(
        chat_type=ChatType.PRIVATE,
        creator_id=creator_id,
        recipient_id=recipient_id
    )
    db.add(chat)
    db.commit()
    db.refresh(chat)
    logger.info(f"‚úÖ Chat created: {chat.id}")
    
    # –î–æ–¥–∞—î–º–æ –æ–±–æ—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ —è–∫ —É—á–∞—Å–Ω–∏–∫—ñ–≤
    creator_member = ChatMember(
        user_id=creator_id,
        chat_id=chat.id,
        role=MemberRole.PARTICIPANT,
        status=MemberStatus.ACTIVE
    )
    recipient_member = ChatMember(
        user_id=recipient_id,
        chat_id=chat.id,
        role=MemberRole.PARTICIPANT,
        status=MemberStatus.ACTIVE
    )
    
    db.add(creator_member)
    db.add(recipient_member)
    db.commit()
    logger.info(f"‚úÖ Members added: creator={creator_id}, recipient={recipient_id}")
    
    return chat

def _ensure_user_membership(db: Session, chat_id: int, user_id: int) -> None:
    """Create ACTIVE participant membership if missing. Safe to call repeatedly."""
    member = db.query(ChatMember).filter(
        ChatMember.chat_id == chat_id,
        ChatMember.user_id == user_id,
        ChatMember.status == MemberStatus.ACTIVE
    ).first()
    if member:
        return
    new_member = ChatMember(
        user_id=user_id,
        chat_id=chat_id,
        role=MemberRole.PARTICIPANT,
        status=MemberStatus.ACTIVE
    )
    db.add(new_member)
    db.commit()
    logger.info(f"‚úÖ Ensured membership: user={user_id} chat={chat_id}")

def get_or_create_private_chat(db: Session, user_id: int, other_user_id: int) -> Chat:
    """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —ñ—Å–Ω—É—é—á–æ–≥–æ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ —á–∞—Ç—É –∞–±–æ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–æ–≤–æ–≥–æ"""
    # –°–ø–æ—á–∞—Ç–∫—É —à—É–∫–∞—î–º–æ —ñ—Å–Ω—É—é—á–∏–π —á–∞—Ç
    existing_chat = db.query(Chat).filter(
        ((Chat.creator_id == user_id) & (Chat.recipient_id == other_user_id)) |
        ((Chat.creator_id == other_user_id) & (Chat.recipient_id == user_id)),
        Chat.chat_type == ChatType.PRIVATE
    ).first()
    
    if existing_chat:
        return existing_chat
    
    # –Ø–∫—â–æ —á–∞—Ç –Ω–µ —ñ—Å–Ω—É—î, —Å—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤–∏–π
    return create_private_chat(db, user_id, other_user_id)

def add_member_to_chat(db: Session, chat_id: int, user_id: int, role: str = "participant") -> ChatMember:
    """–î–æ–¥–∞–≤–∞–Ω–Ω—è —É—á–∞—Å–Ω–∏–∫–∞ –¥–æ —á–∞—Ç—É (–¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–∏—Ö —á–∞—Ç—ñ–≤ –∑–∞–∑–≤–∏—á–∞–π –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ)"""
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤–∂–µ –≤ —á–∞—Ç—ñ
    existing_member = db.query(ChatMember).filter(
        ChatMember.chat_id == chat_id,
        ChatMember.user_id == user_id
    ).first()
    
    if existing_member:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User is already a member of this chat"
        )
    
    member = ChatMember(
        user_id=user_id,
        chat_id=chat_id,
        role=MemberRole.PARTICIPANT,
        status=MemberStatus.ACTIVE
    )
    db.add(member)
    db.commit()
    db.refresh(member)
    
    return member

def send_message(db: Session, message_data: dict, author_id: int) -> Message:
    """–í—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
    logger.info(f"üîç Sending message: chat_id={message_data['chat_id']}, author_id={author_id}")
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á —î —É—á–∞—Å–Ω–∏–∫–æ–º —á–∞—Ç—É (–∑ –∞–≤—Ç–æ-–¥–æ–¥–∞–≤–∞–Ω–Ω—è–º –¥–ª—è –∞–≤—Ç–æ—Ä–∞/–æ–¥–µ—Ä–∂—É–≤–∞—á–∞ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ —á–∞—Ç—É)
    member = db.query(ChatMember).filter(
        ChatMember.chat_id == message_data["chat_id"],
        ChatMember.user_id == author_id,
        ChatMember.status == MemberStatus.ACTIVE
    ).first()
    if not member:
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —ñ–º–ø–ª—ñ—Ü–∏—Ç–Ω–µ —á–ª–µ–Ω—Å—Ç–≤–æ —á–µ—Ä–µ–∑ creator/recipient —ñ –∑–∞–±–µ–∑–ø–µ—á—É—î–º–æ —Ä—è–¥–æ–∫ —É chat_members
        chat = db.query(Chat).filter(Chat.id == message_data["chat_id"]).first()
        if chat and (chat.creator_id == author_id or chat.recipient_id == author_id):
            try:
                _ensure_user_membership(db, chat.id, author_id)
                member = db.query(ChatMember).filter(
                    ChatMember.chat_id == message_data["chat_id"],
                    ChatMember.user_id == author_id,
                    ChatMember.status == MemberStatus.ACTIVE
                ).first()
            except Exception as e:
                logger.error(f"‚ö†Ô∏è Failed to ensure membership before sending: {e}")
        
    logger.info(f"üîç Chat member check after ensure: {member}")
    if not member:
        logger.error(f"‚ùå User {author_id} is not a member of chat {message_data['chat_id']}")
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You are not a member of this chat"
        )
    
    message = Message(
        content=message_data["content"],
        message_type=message_data.get("message_type", "text"),
        author_id=author_id,
        chat_id=message_data["chat_id"]
    )
    db.add(message)
    db.commit()
    db.refresh(message)
    
    logger.info(f"‚úÖ Message sent: {message.id}")
    return message

def edit_message(db: Session, message_id: int, new_content: str, user_id: int) -> Message:
    """–†–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
    message = db.query(Message).filter(Message.id == message_id).first()
    
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    
    if message.author_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only edit your own messages"
        )
    
    if message.is_deleted:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Cannot edit deleted message"
        )
    
    message.content = new_content
    message.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(message)
    
    return message

def delete_message(db: Session, message_id: int, user_id: int) -> bool:
    """–í–∏–¥–∞–ª–µ–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (soft delete)"""
    message = db.query(Message).filter(Message.id == message_id).first()
    
    if not message:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Message not found"
        )
    
    if message.author_id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You can only delete your own messages"
        )
    
    message.is_deleted = True
    db.commit()
    
    return True

def upload_file(db: Session, file: UploadFile, message_id: int) -> FileAttachment:
    """–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—É"""
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä–æ–∑–º—ñ—Ä —Ñ–∞–π–ª—É
    if file.size and file.size > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File size exceeds maximum allowed size"
        )
    
    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è
    file_extension = os.path.splitext(file.filename)[1].lower()
    if file_extension not in ALLOWED_EXTENSIONS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="File type not allowed"
        )
    
    # –ì–µ–Ω–µ—Ä—É—î–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω–µ —ñ–º'—è —Ñ–∞–π–ª—É
    timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    safe_filename = f"{timestamp}_{file.filename}"
    file_path = os.path.join(UPLOAD_DIR, safe_filename)
    
    # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ñ–∞–π–ª
    with open(file_path, "wb") as buffer:
        shutil.copyfileobj(file.file, buffer)
    
    # –°—Ç–≤–æ—Ä—é—î–º–æ –∑–∞–ø–∏—Å –≤ –±–∞–∑—ñ
    attachment = FileAttachment(
        filename=file.filename,
        file_path=file_path,
        file_size=os.path.getsize(file_path),
        mime_type=file.content_type or "application/octet-stream",
        message_id=message_id
    )
    db.add(attachment)
    db.commit()
    db.refresh(attachment)
    
    return attachment

def get_chat_messages(db: Session, chat_id: int, skip: int = 0, limit: int = 50) -> List[Message]:
    """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å —á–∞—Ç—É"""
    messages = db.query(Message).filter(
        Message.chat_id == chat_id,
        Message.is_deleted == False
    ).order_by(Message.created_at.desc()).offset(skip).limit(limit).all()
    
    return messages

def get_user_chats(db: Session, user_id: int) -> List[Chat]:
    """–û—Ç—Ä–∏–º–∞–Ω–Ω—è –ø—Ä–∏–≤–∞—Ç–Ω–∏—Ö —á–∞—Ç—ñ–≤ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
    logger.info(f"üîç Getting chats for user {user_id}")
    # Chats via explicit membership rows
    member_rows = db.query(ChatMember).filter(
        ChatMember.user_id == user_id,
        ChatMember.status == MemberStatus.ACTIVE
    ).all()
    member_chat_ids = {row.chat_id for row in member_rows}

    # Chats where the user is creator or recipient (implicit membership for private chats)
    # Implicit chats: do not rely on enum equality to avoid legacy enum-label mismatch
    implicit_chats = db.query(Chat).filter(
        (Chat.creator_id == user_id) | (Chat.recipient_id == user_id)
    ).all()
    implicit_chat_ids = {c.id for c in implicit_chats}

    # Ensure membership rows for implicit chats (idempotent backfill for current user)
    for chat in implicit_chats:
        try:
            _ensure_user_membership(db, chat.id, chat.creator_id)
            _ensure_user_membership(db, chat.id, chat.recipient_id)
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Failed to ensure membership for chat {chat.id}: {e}")

    # Union of both
    all_chat_ids = list(member_chat_ids | implicit_chat_ids)
    if not all_chat_ids:
        logger.info("üîç No chats found for user")
        return []

    chats = db.query(Chat).filter(
        Chat.id.in_(all_chat_ids)
    ).all()
    logger.info(f"üîç Chats found: {[c.id for c in chats]}")
    return chats

def get_chat_participants(db: Session, chat_id: int) -> List[User]:
    """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —É—á–∞—Å–Ω–∏–∫—ñ–≤ –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ —á–∞—Ç—É"""
    members = db.query(ChatMember).filter(
        ChatMember.chat_id == chat_id,
        ChatMember.status == MemberStatus.ACTIVE
    ).all()
    
    user_ids = [member.user_id for member in members]
    users = db.query(User).filter(User.id.in_(user_ids)).all()
    
    return users

def is_user_in_chat(db: Session, chat_id: int, user_id: int) -> bool:
    """–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á —î —É—á–∞—Å–Ω–∏–∫–æ–º —á–∞—Ç—É"""
    logger.info(f"üîç Checking if user {user_id} is in chat {chat_id}")
    # Fast path: explicit membership row exists
    member = db.query(ChatMember).filter(
        ChatMember.chat_id == chat_id,
        ChatMember.user_id == user_id,
        ChatMember.status == MemberStatus.ACTIVE
    ).first()
    if member:
        logger.info("üîç Member row exists: True")
        return True

    # Fallback for private chats: user is creator or recipient
    # Avoid enum comparison to tolerate legacy rows
    chat = db.query(Chat).filter(Chat.id == chat_id).first()
    if not chat:
        logger.info("üîç Chat not found or not private")
        return False

    if chat.creator_id == user_id or chat.recipient_id == user_id:
        logger.info("üîç Implicit membership via chat creator/recipient: True")
        # Best-effort: ensure membership row for future queries
        try:
            _ensure_user_membership(db, chat_id, user_id)
        except Exception as e:
            logger.error(f"‚ö†Ô∏è Failed to ensure membership row: {e}")
        return True

    logger.info("üîç User is NOT in chat")
    return False
